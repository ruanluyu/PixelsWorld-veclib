# 在Lua中使用glsl的语法

我们提供了能在Lua中像glsl一样进行向量和矩阵运算的功能

> 如果你熟悉glsl，那么可以直接跳转到文末的[与glsl的区别](##与glsl的区别)和[代码样例](##代码样例)对照代码和运行结果以快速浏览我们支持的语法

## 数据类型

目前支持向量和矩阵两种数据类型

### 向量（vector）

- vec2
- vec3
- vec4

### 矩阵（matrix）

- mat2
- mat3
- mat4
- mat2x2
- mat2x3
- mat2x4
- mat3x2
- mat3x3
- mat3x4
- mat4x2
- mat4x3
- mat4x4
> 与glsl相同，这里的矩阵都是列优先的，即nxm代表n列m行。

## 函数列表

### 构造函数
- [vecn](###vecn)
- [matnxm](###matnxm)
> 它们只是一类构造函数名字的简写，构造函数实际的名字需要将其中的n和m替换为2、3、4中的任意一个数

### 方法
- [dot](###dot)
- [cross](###cross)
- [normalize](###normalize)
- [transpose](###transpose)
- [tr](###tr)
- [det](###det)
- [inv](###inv)
> `cross`方法只支持`vec3`

### 运算符
- [加法](###加法)
- [减法](###减法)
- [取负](###取负)
- [乘法](###乘法)
- [幂](###幂)
- [相等](###相等)
- [索引](###索引)
- [索引赋值](###索引赋值)
- [取长度](###取长度)
- [连接](###连接)
- [转为字符串](###转为字符串)

## 函数详细说明

### vecn

这是向量的构造函数，其中字母n需要替换为2、3、4中任意一个数。得到的三种构造函数分别对应三种不同长度的向量，它们除了长度及与长度有关的性质外完全相同。

对于一个构造函数`vecn`，它有两种使用方式。
1. 你可以只传入一个数a，此时构造函数将返回一个由n个a组成的向量。
2. 你可以传入多个数和向量，满足他们的总长度大于或等于n，此时构造函数将返回一个由前n个数组成的向量，多余的部分将被舍弃。

```lua
p1 = vec2(2.0); --p1为[2.0, 2.0]

p2 = vec4(1.0, p1, 4.0); --p2为[1.0, 2.0, 2.0, 4.0]
	
p3 = vec4(1.0, 2.0, 3.0, 4.0); --p3为[1.0, 2.0, 3.0, 4.0]
```

### matnxm

这是矩阵的构造函数，其中字母n和m需要替换为2、3、4中任意一个数。得到的九种构造函数分别对应九种不同大小的向量，它们除了大小及与大小有关的性质外完全相同。

当n和m相等时，你可以将其简写为`matn`

对于一个构造函数`matnxm`，它有三种使用方式。
1. 如果n和m相等，此时你可以只传入一个数a，构造函数将返回一个边长为n的，主对角线上元素均为a的数量矩阵。
2. 你可以传入多个数和向量，满足他们的总长度等于n且不会有向量被分给不同的两列，此时构造函数将返回一个由这些数和向量依次按列优先填充组成的矩阵。
3. 你可以传入一个列数和行数分别不小于n和m的矩阵，构造函数会截取传入矩阵的n列m行作为新矩阵返回。

```lua
m1 = mat4(1.0);

m2 = mat2x3(m1);

v2 = vec2(1.0, 2.0);
v3 = vec3(1.0, 2.0, 3.0);
m3 = mat3(0.0, v2, v3, 2.0, 3.0, 4.0);

--m4 = mat2(0.0, v2, 3.0); --v2中的两个数被分给了不同的两列，构造函数会阻止这样的使用方法
```
以上代码得到的矩阵分别为

m1：

$$
\begin{pmatrix}
1.0 & 0.0 & 0.0 & 0.0 \\
0.0 & 1.0 & 0.0 & 0.0 \\
0.0 & 0.0 & 1.0 & 0.0 \\
0.0 & 0.0 & 0.0 & 1.0
\end{pmatrix}
$$

m2:

$$
\begin{pmatrix}
1.0 & 0.0 \\
0.0 & 1.0 \\
0.0 & 0.0
\end{pmatrix}
$$

m3:

$$
\begin{pmatrix}
0.0 & 1.0 & 2.0 \\
1.0 & 2.0 & 3.0 \\
2.0 & 3.0 & 4.0
\end{pmatrix}
$$

### dot
### cross
### normalize
### transpose
### tr
### det
### inv

### 加法

向量支持与数（``number``）或向量的加法运算

当向量``v``与数``n``进行加法运算时，表达式将返回一个新的向量，这个向量的每个分量的值是向量``v``对应分量的值加上``n``的结果

例如：

```lua
v1 = vec4(1.0, 2.0, 3.0, 4.0);
n = 10;

print(v1 + n); --打印[11.0,12.0,13.0,14.0]
```
当向量``v1``与向量``v2``进行加法运算时，表达式将返回一个新的向量，这个向量的每个分量的值是向量``v1``与``v2``对应分量的值的和

例如：

```lua
v1 = vec4(1.0, 2.0, 3.0, 4.0);
v2 = vec4(0.4, 0.3, 0.2, 0.1);

print(v1 + v2); --打印[1.4,2.3,3.2,4.1]
```

### 减法
### 取负
### 乘法
### 幂
### 相等
### 索引
### 索引赋值
### 取长度
### 连接
### 转为字符串

## Swizzling

## 与glsl的区别

出于效率和代码风格等因素，我们的实现中有许多细节与原生glsl语法不同，在编写时应该注意
1. 向量与矩阵第一个位置的索引数为1，而不是0
2. 我们实现的向量和矩阵只有`number`型，整形和浮点型可以同时出现在一个向量或矩阵内，我们没有实现布尔型的向量或矩阵
3. 在使用[Swizzling](##Swizzling)时，我们不会严格地禁止混合使用不同类型的字母，也不会阻止在被赋值向量中使用重复字母，详细说明请查阅[Swizzling](##Swizzling)小节

## 代码样例

将以下代码复制到工作区运行查看结果

```lua
require('glua');

v1 = vec2(1);
v2 = vec3(1, 2, 3);
v3 = vec4(1, vec2(2, 3), 4);
v4 = vec4(10, 20, 30, 40);
v5 = vec3(2);

print('v1:\n' .. v1 .. '\n');
print('v2:\n' .. v2 .. '\n');
print('v3:\n' .. v3 .. '\n');
print('v4:\n' .. v4 .. '\n');

print('normalized v3:\n' .. v3:normalize() .. '\n');

print('length of v4:\n' .. #v4 .. '\n');
print('v4 - 1:\n' .. v4 - 1 .. '\n');
print('v3 - v4:\n' .. v3 - v4 .. '\n');
print('v3 dot v4:\n' .. v3:dot(v4) .. '\n');
print('v2 cross v5:\n' .. v2:cross(v5) ..  '\n');

print('v3[2]:\n' .. v3[2] .. '\n');
print('let v3[3] = 0, then v3:');
v3[3] = 0;
print(v3 .. '\n');
print('v3.wzyx:\n' .. v3.wzyx .. '\n');
print('let v4.xyz = v3.zyx, then v4:');
v4.xyz = v3.zyx;
print(v4 .. '\n');

m1 = mat2(1);
m2 = mat3(1 ,5 ,2 ,8 ,7 ,9 ,3 ,6 ,0);
m3 = mat4(1, vec3(2, 3, 4), vec2(5, 6), vec2(7, 8), 9, 10, 11, 12, vec4(13, 14, 15, 16));
m4 = mat4x3(1, 4, 3, 6, 5, 4, 9, 7, 8, 2, 6, 4);
m5 = mat3x4(5, 6, 3, 5, 4, 7, 8, 9, 2, 0, 8, 5);
m6 = mat3x4(10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10);
m7 = mat2x3(m3);

print('m1:\n' .. m1 .. '\n');
print('m2:\n' .. m2 .. '\n');
print('m3:\n' .. m3 .. '\n');
print('m4:\n' .. m4 .. '\n');
print('m5:\n' .. m5 .. '\n');
print('m6:\n' .. m6 .. '\n');
print('m7:\n' .. m7 .. '\n');

print('transposed m2:\n' .. m2:transpose() .. '\n');
print('det of m2:\n' .. m2:det() .. '\n');
print('inv of m2:\n' .. m2:inv() .. '\n');
print('trace of m2:\n' .. m2:tr() .. '\n');

print('length of a matrix nxm is a table {n, m}:');
print('n is colnum of m5: ' .. (#m5)[1]);
print('m is row of m5: ' .. (#m5)[2] .. '\n');
print('m5 * m4:\n' .. m5 * m4 .. '\n');
print('m6 - m5:\n' .. m6 - m5 .. '\n');

print('v3 * m6:\n' .. v3 * m6 .. '\n');
print('m6 * v2:\n' .. m6 * v2 .. '\n');

print('m7[2]:\n' .. m7[2] .. '\n');
print('m7[1][2]:\n' .. m7[1][2] .. '\n');

print('let m7[2] = vec3(4, 5, 6), then m7:');
m7[2] = vec3(4, 5, 6);
print(m7 .. '\n');

print('let m7[1][2] = 0, then m7:');
m7[1][2] = 0;
print(m7 .. '\n');

print('let m7[1].rb = m7[2].ts, then m7:');
m7[1].rb = m7[2].ts;
print(m7);
```
