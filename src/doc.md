# 在Lua中使用glsl的语法

我们提供了能在Lua中像glsl一样进行向量和矩阵运算的功能

> 如果你熟悉glsl，那么可以直接跳转到文末的[与glsl的区别](##与glsl的区别)和[代码样例](##代码样例)对照代码和运行结果以快速浏览我们支持的语法

> 在以下所有示例代码中，若某行被注释掉，一般表示这种用法是错误的，会抛出异常

## 数据类型

目前支持向量和矩阵两种数据类型

### 向量（vector）

向量的类型为`table`，当`getmetatable`函数接收的参数为向量时，它将返回字符串`’vector‘`，你可以用这种方法判断一个变量的值是不是向量

向量根据长度分为以下三种

- vec2
- vec3
- vec4

> 这里的向量不区分行向量和列向量，它在被用来构造矩阵时视为列向量，在与矩阵相乘时会根据需要视为行向量或列向量

### 矩阵（matrix）

矩阵的类型为`table`，当`getmetatable`函数接收的参数为矩阵时，它将返回字符串`’matrix‘`，你可以用这种方法判断一个变量的值是不是矩阵

矩阵根据大小分为以下九种

- mat2x2（mat2）
- mat2x3
- mat2x4
- mat3x2
- mat3x3（mat3）
- mat3x4
- mat4x2
- mat4x3
- mat4x4（mat4）

> 这里的矩阵都是列优先的，即nxm代表n列m行

## 函数列表

### 构造函数

- [vecn](###vecn)
- [matnxm](###matnxm)

> `vecn`和`matnxm`只是对应类的构造函数名字的通称，构造函数实际的名字是将其中的n和m替换为2、3、4中的任意一个数

### 方法

- [dot](###dot)
- [cross](###cross)
- [normalize](###normalize)
- [transpose](###transpose)
- [tr](###tr)
- [det](###det)
- [inv](###inv)

### 运算符

- [加法](###加法)
- [减法](###减法)
- [取负](###取负)
- [乘法](###乘法)
- [幂](###幂)
- [相等](###相等)
- [索引](###索引)
- [索引赋值](###索引赋值)
- [取长度](###取长度)
- [连接](###连接)
- [转为字符串](###转为字符串)

## 函数详细说明

调用函数时，进行文中没有提到的传入参数的行为均属于未定义的，大多数情况会抛出异常

### vecn

向量的构造函数，其中字母n需要替换为2、3、4中任意一个数，得到的三种构造函数分别对应三种不同长度的向量，它们除了长度及与长度有关的性质外完全相同

对于一个构造函数`vecn`，它有两种使用方式。

1. 你可以只传入一个`number`，此时构造函数将返回一个长度为n，所有元素均为传入值的向量

2. 你可以传入多个`number`或向量，满足他们的总长度大于或等于n，此时构造函数将返回由前n个数构成的向量，多余的部分将被舍弃

```lua
p1 = vec2(2.0);
print(p1); --> [2.0, 2.0]

p2 = vec4(1.0, p1, 4.0);
print(p2); --> [1.0, 2.0, 2.0, 4.0]
	
p3 = vec4(1.0, 2.0, p2);
print(p3); --> [1.0, 2.0, 1.0, 2.0]
```

> 由于Lua语言特性限制，函数无法区分自己被调用时是只传入了一个参数还是传入了多个参数但除了第一个外其他都是`nil`，因此需要您注意变量在传入前是否由于某些意外变成了`nil`

### matnxm

矩阵的构造函数，其中字母n和m需要替换为2、3、4中任意一个数，得到的九种构造函数分别对应九种不同大小的矩阵，它们除了大小及与大小有关的性质外完全相同

当n和m相等时，你可以将其简写为`matn`

对于一个构造函数`matnxm`，它有三种使用方式。

1. 如果n和m相等，即矩阵为方阵，此时你可以只传入一个`number`，构造函数将返回一个边长为n的，主对角线上元素均为传入值的数量矩阵

2. 你可以传入多个`number`或向量，满足他们的总长度等于n×m、且在分割成列时没有向量会被分给不同的两列，此时构造函数将返回一个由这些数和向量中的数依次按列优先填充组成的矩阵

3. 你可以传入一个列数不小于n且行数不小于m的矩阵，构造函数会截取传入矩阵的前n列m行作为新矩阵返回

```lua
m1 = mat4(1.0);

m2 = mat2x3(m1);

v2 = vec2(1.0, 2.0);
v3 = vec3(3.0, 4.0, 5.0);
m3 = mat3(0.0, v2, v3, 6.0, 7.0, 8.0);

--m4 = mat3x4(1.0); --只有方阵才可以这样调用构造函数

--m5 = mat2(0.0, v2, 3.0); --v2中的两个数被分给了不同的两列，构造函数会阻止这样的使用方法
```
以上代码得到的矩阵分别为

m1：

$$
\begin{pmatrix}
1.0 & 0.0 & 0.0 & 0.0 \\
0.0 & 1.0 & 0.0 & 0.0 \\
0.0 & 0.0 & 1.0 & 0.0 \\
0.0 & 0.0 & 0.0 & 1.0
\end{pmatrix}
$$

m2:

$$
\begin{pmatrix}
1.0 & 0.0 \\
0.0 & 1.0 \\
0.0 & 0.0
\end{pmatrix}
$$

m3:

$$
\begin{pmatrix}
0.0 & 3.0 & 6.0 \\
1.0 & 4.0 & 7.0 \\
2.0 & 5.0 & 8.0
\end{pmatrix}
$$

> 与向量相同，请注意传入参数是否意外变为`nil`

### dot

向量的内积运算，俗称“点乘”

函数需要传入两个长度相同的向量，返回一个`number`，即传入的两个向量的内积

```lua
v1 = vec3(1.0, 2.0, 3.0);
v2 = vec3(4.0, 5.0, 6.0);
v3 = dot(v1, v2);
print(v3); --> 32.0
```

向量类型内也提供了这个方法，你可以直接调用，它们是同一个函数

```lua
v1 = vec3(1.0, 2.0, 3.0);
v2 = vec3(4.0, 5.0, 6.0);
print(v1:dot(v2)); --> 32.0
```

### cross

向量的外积运算，俗称“叉乘”

函数需要传入两个长度为3的向量，返回一个长度为3向量，即传入的两个向量的外积

```lua
v1 = vec3(1.0, 2.0, 3.0);
v2 = vec3(4.0, 5.0, 6.0);
v3 = cross(v1, v2);
print(v3); --> [-3.0, 6.0, -3.0]
```

向量类型内也提供了这个方法，你可以直接调用，它们是同一个函数

```lua
v1 = vec3(1.0, 2.0, 3.0);
v2 = vec3(4.0, 5.0, 6.0);
print(v1:cross(v2)); --> [-3.0, 6.0, -3.0]
```

> cross函数只支持长度为3的向量，并不支持长度为2的向量，也不支持三个长度为4的向量

### normalize

向量的标准化

函数需要传入一个向量，返回一个与传入向量长度相同的向量，即传入向量标准化后的向量

```lua
v1 = vec4(1.0, 1.0, 1.0, 1.0);
v2 = normalize(v1);
print(v2); --> [0.5, 0.5, 0.5, 0.5]
```

向量类型内也提供了这个方法，你可以直接调用，它们是同一个函数

```lua
v1 = vec4(1.0, 1.0, 1.0, 1.0);
print(v1:normalize()); --> [0.5, 0.5, 0.5, 0.5]
```

### transpose

矩阵的转置

函数需要输入一个矩阵，返回一个列数为输入矩阵的行数、行数为输入矩阵列数的矩阵，即输入矩阵的转置

```lua
m1 = mat2x3(1.0, 2.0, 3.0, 10.0, 20.0, 30.0);
print(m1); --> [[1.0, 2.0, 3.0], [10.0, 20.0, 30.0]]

m2 = transpose(m1);
print(m2); --> [[1.0, 10.0], [2.0, 20.0], [3.0, 30.0]]
```

矩阵类型内也提供了这个方法，你可以直接调用，它们是同一个函数

```lua
m1 = mat2x3(1.0, 2.0, 3.0, 10.0, 20.0, 30.0);
print(m1); --> [[1.0, 2.0, 3.0], [10.0, 20.0, 30.0]]
print(m2:transpose()); --> [[1.0, 10.0], [2.0, 20.0], [3.0, 30.0]]
```

### tr

矩阵的迹

函数需要输入一个方阵，返回一个`number`，即输入矩阵的迹

```lua
m1 = mat3(1.0);
print(tr(m1)); --> 3.0
```

矩阵类型内也提供了这个方法，你可以直接调用，它们是同一个函数

```lua
m1 = mat3(1.0);
print(m1:tr()); --> 3.0
```

### det

矩阵的行列式

函数需要传入一个矩阵，且可以再传入一个`number`，返回一个`number`，即矩阵对应的行列式的值

若传入了第二个参数（设其为n），则在计算行列式时将绝对值小于10^-n的数视为0，若没有传入或传入`nil`则仅将0视为0

> 对于非方阵，该函数返回0，而不是抛出异常

```lua
m1 = mat2(1.0, 2.0, 3.0, 4.0);
print(det(m1)); --> -2.0

m2 = mat3x4(5, 6, 3, 5, 4, 7, 8, 9, 2, 0, 8, 5);
m3 = mat4x3(1, 4, 3, 6, 5, 4, 9, 7, 8, 2, 6, 4);
m4 = m2 * m3;
print(det(m4)); --> -2.627231765473e-11
print(det(m4, 10)); --> 0
```

矩阵类型内也提供了这个方法，你可以直接调用，它们是同一个函数

```lua
m1 = mat2(1.0, 2.0, 3.0, 4.0);
print(m1:det()); --> -2.0

m2 = mat3x4(5, 6, 3, 5, 4, 7, 8, 9, 2, 0, 8, 5);
m3 = mat4x3(1, 4, 3, 6, 5, 4, 9, 7, 8, 2, 6, 4);
m4 = m2 * m3;
print(m4:det()); --> -2.627231765473e-11
print(m4:det(10)); --> 0
```

### inv

矩阵的逆

函数需要输入一个可逆矩阵，且可以再输入一个`number`，返回与输入矩阵大小相同的矩阵，即输入矩阵的逆

若传入了第二个参数（设其为n），则在计算逆时将绝对值小于10^-n的数视为0，若没有传入或传入`nil`则仅将0视为0

```lua
m1 = mat2(1.0, 2.0, 3.0, 4.0);
print(inv(m1)); --> [[-2.0, 1.0], [1.5, -0.5]]

m2 = mat3x4(5, 6, 3, 5, 4, 7, 8, 9, 2, 0, 8, 5);
m3 = mat4x3(1, 4, 3, 6, 5, 4, 9, 7, 8, 2, 6, 4);
m4 = m2 * m3;
print(inv(m4)); --返回一个由10^14和10^-14数量级的数构成的矩阵
--print(inv(m4, 10)); --判断出该矩阵不可逆并抛出异常
```

矩阵类型内也提供了这个方法，你可以直接调用，它们是同一个函数

```lua
m1 = mat2(1.0, 2.0, 3.0, 4.0);
print(m1:inv()); --> [[-2.0, 1.0], [1.5, -0.5]]

m2 = mat3x4(5, 6, 3, 5, 4, 7, 8, 9, 2, 0, 8, 5);
m3 = mat4x3(1, 4, 3, 6, 5, 4, 9, 7, 8, 2, 6, 4);
m4 = m2 * m3;
print(m4:inv()); --返回由10^14和10^-14数量级的数构成的矩阵
--print(m4:inv(10)); --判断出该矩阵不可逆并抛出异常
```

### 加法

向量和矩阵都重载了加法运算，您可以直接使用符号‘`+`’进行加法运算

若`a`和`b`至少有一个为向量或矩阵，则对于表达式‘`a + b`’有

1. 当`a`和`b`一个为向量、一个为`number`时，表达式返回一个与传入向量长度相等的向量，其中每个位置上的值分别为传入向量对应位置上的值加上`number`的和

2. 当`a`和`b`为两个长度相等的向量时，表达式返回一个与传入向量长度相等的向量，其中每个位置上的值分别为两个传入向量对应位置上的值之和

3. 当`a`和`b`为两个大小相同的矩阵时，表达式返回一个与传入矩阵大小相同的矩阵，其中每个位置上的值分别为两个传入矩阵对应位置上的值之和

```lua
v1 = vec3(1.0, 2.0, 3.0);
v2 = vec3(10.0, 20.0, 30.0);
print(v1 + 0.1); --> [1.1, 2.1, 3.1]
print(v1 + v2); --> [11.0, 22.0, 33.0]

m1 = mat2(1.0, 2.0, 3.0, 4.0);
m2 = mat2(10.0, 20.0, 30.0, 40.0);
print(m1 + m2); --> [[11.0, 22.0], [33.0, 44.0]]
```

### 减法

向量和矩阵都重载了减法运算，您可以直接使用符号‘`-`’进行减法运算

减法运算实际上是调用了取负运算和加法运算，即表达式‘`a - b`’等价于‘`a + (-b)`’，详细用法参照[加法](###加法)和[取负](###取负)，这里不多赘述

### 取负

向量和矩阵都重载了取负运算，您可以直接使用符号‘`-`’进行取负运算

若`a`为向量或矩阵，则对于表达式‘`-a`’有

1. 当`a`为向量时，表达式返回一个与传入向量长度相等的向量，其中每个位置上的值分别为传入向量对应位置上的值的相反数

2. 当`a`为矩阵时，表达式返回一个与传入向量大小相同的矩阵，其中每个位置上的值分别为传入矩阵对应位置上的值的相反数

```lua
v1 = vec3(1.0, 2.0, 3.0);
print(-v1); --> [-1.0, -2.0, -3.0]

m1 = mat2(1.0, 2.0, 3.0, 4.0);
print(-m1); --> [[-1.0, -2.0], [-3.0, -4.0]]
```

### 乘法

向量和矩阵都重载了乘法运算，您可以直接使用符号‘`*`’进行乘法运算

若`a`和`b`至少有一个为向量或矩阵，则对于表达式‘`a * b`’有

1. 当`a`和`b`一个为向量、一个为`number`时，表达式返回一个长度与传入向量相等的向量，其中每个位置上的值分别为传入向量对应位置上的值与`number`的积

2. 当`a`和`b`一个为矩阵、一个为`number`时，表达式返回一个大小与传入矩阵相同的矩阵，其中每个位置上的值分别为传入矩阵对应位置上的值与`number`的积

3. 当`a`和`b`一个为向量、一个为矩阵，且在`a`为向量时`a`的长度与`b`的行数相等，在`b`为向量时`a`的列数与`b`的长度相等时，表达式返回一个向量，即传入向量与传入矩阵在数学上相乘的结果

4. 当`a`和`b`均为矩阵，且`a`的列数等于`b`的行数时，表达式返回一个矩阵，即两个传入矩阵在数学上相乘的结果

```lua
v1 = vec3(2.0);
m1 = mat3x2(1.0, 2.0, 3.0, 4.0, 5.0, 6.0);
m2 = mat4x3(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0);

print(v1 * 2); --> [4.0, 4.0, 4.0]
print(m1 * 2); --> [[2.0, 4.0], [6.0, 8.0], [10.0, 12.0]]
print(m1 * v1); --> [18.0, 24.0]
print(v1 * m2); --> [12.0, 30.0, 48.0, 66.0]
print(m1 * m2); --> [[22.0, 28.0], [49.0, 64.0], [76.0, 100.0], [103.0, 136.0]]
```

> 为了避免混淆，乘法运算符不支持向量与向量的运算，请使用函数[dot](###dot)或[cross](###cross)

### 幂

矩阵重载了幂运算，您可以直接使用符号‘`^`’进行幂运算

若`a`为方阵，`b`为一个整数，则对于表达式‘`a ^ b`’有

1. 当`b`为0时，表达式返回一个大小与传入矩阵相同的单位矩阵

2. 当`b`为正数时，表达式返回`b`个传入矩阵相乘的结果

3. 当`b`为负数时，表达式返回`-b`个传入矩阵的逆相乘的结果

```lua
m1 = mat(1.0, 2.0, 3.0, 4.0);
print(m1 ^ 2); --> [[7.0, 10.0], [15.0, 22.0]]
print(m1 ^ -2); --> [[5.5, -2.5], [-3.75, 1.75]]
print(m1 ^ 0); --> [[1, 0], [0, 1]]
```

### 相等

向量和矩阵都重载了相等运算，您可以直接使用符号‘`==`’判断两个向量或矩阵是否相等

若`a`和`b`至少有一个是向量或矩阵，则对于表达式‘`a == b`’有

1. 若`a`与`b`类型不同，表达式返回`false`

2. 若`a`与`b`长度或大小不同，表达式返回`false`

3. 若`a`与`b`各个对应位置上的值都相等，表达式返回`true`，否则返回`false`

> 在Lua中，可以表示为整数的小数与其对应的整数是相等的，因此在向量和矩阵判断中也会视为相等

```lua
v1 = vec3(1.0);
v2 = vec3(1.0, 1.0, 1.0);
print(v1 == v2); --> true

m1 = mat2(1);
m2 = mat2(1.0, 0.0, 0.0, 1.0);
print(m1 == m2); --> true

print(v1 == m1); --> false
```

### 索引

出于对数据结构的保护，以及对向量[Swizzling](##Swizzling)操作的支持，向量和矩阵的索引操作被重载

若`t`为向量，则对于表达式‘`t[k]`’有

1. 当`k`为正整数且不大于`t`的长度时，表达式返回向量`t`第`k`个位置上的`number`

2. 当`k`为`string`时，视为进行[Swizzling](##Swizzling)的取值操作

若`t`为矩阵，则对于表达式‘`t[k]`’有

1. 当`k`为正整数且不大于`t`的列数时，表达式返回矩阵`t`的第`k`列向量的引用

注意：由于返回值是引用，所以一个变量`a`接收了返回值后，修改`a`内部的值，原矩阵`t`中对应的值也会被修改

```lua
m1 = mat2(1.0);
print(m1); --> [[1.0, 0.0], [0.0, 1.0]]

v1 = m1[1];
v1[1] = 2.0;
print(m1); --> [[2.0, 0.0], [0.0, 1.0]]
```

为了避免这种情况发生，在赋值时可以额外加一个数0，此时被提供的是与`t`无关的新向量

```lua
m1 = mat2(1.0);
print(m1); --> [[1.0, 0.0], [0.0, 1.0]]

v1 = m1[1] + 0;
print(v1); --> [1.0, 0.0]

v1[1] = 2.0;
print(m1); --> [[1.0, 0.0], [0.0, 1.0]]
print(v1); --> [2.0, 0.0]
```

### 索引赋值

出于对数据结构的保护，以及对向量[Swizzling](##Swizzling)操作的支持，向量和矩阵的索引赋值操作被重载

若`t`为向量，`v`为`number`，则对于表达式‘`t[k] = v`’有

1. 当`k`为正整数且不大于`t`的长度时，表达式会将向量`t`第`k`个位置上的值改为`v`

2. 当`k`为`string`时，视为进行[Swizzling](##Swizzling)的赋值操作

若`t`为矩阵，`v`为`number`，则对于表达式‘`t[k] = v`’有

1. 当`k`为正整数且不大于`t`的列数时，表达式将矩阵`t`的第`k`列向量引用向`v`

注意：由于赋值是直接引用，所以如果修改提供值的变量`v`内的值，原矩阵`t`中对应的值也会被修改

```lua
m1 = mat2(1.0);
v1 = vec2(1.0, 1.0);
m1[1] = v1;
print(m1); --> [[1.0, 1.0], [0.0, 1.0]]

v1[1] = 2.0;
print(m1); --> [[2.0, 0.0], [0.0, 1.0]]
```

为了避免这种情况发生，在赋值时可以额外加一个数0，此时被赋值的是与`v`无关的新向量

```lua
m1 = mat2(1.0);
v1 = vec2(1.0, 1.0);
m1[1] = v1 + 0;
print(m1); --> [[1.0, 1.0], [0.0, 1.0]]

v1[1] = 2.0;
print(m1); --> [[1.0, 1.0], [0.0, 1.0]]
```

### 取长度

向量和矩阵都重载了取长度运算，您可以直接使用符号‘`#`’对向量或矩阵取长度

若`t`为向量，表达式’`#t`‘将返回向量`t`的长度

若`t`为n×m矩阵，表达式’`#t`‘将返回矩阵`t`中元素的个数，即`n × m`

```lua
v1 = vec4(1.0);
print(#v1); --> 4

m1 = mat4(1.0);
print(#m1); --> 16
```

### 转为字符串

向量和矩阵都重载了`tostring`，您可以使用print直接打印向量或矩阵

若`t`是向量，则表达式‘`print(t)`’会向标准输出打印向量内的所有值，整个字符串用中括号扩起，值之间用‘, ’分割

若`t`是矩阵，则表达式‘`print(t)`’会向标准输出打印矩阵内所有列向量的`tostring`，字符串用中括号扩起，列之间用‘, ’分割

```lua
v1 = vec4(1.0);
print(v1); --> [1.0, 1.0, 1.0, 1.0]

m1 = mat2x3(vec3(1.0), vec3(2.0));
print(m1); --> [[1.0, 1.0, 1.0], [2.0, 2.0, 2.0]]
```

### 连接

向量和矩阵都重载了连接运算，您可以直接使用符号‘`..`’连接向量和矩阵等可以连接的值

若`t1`和`t2`至少有一个是向量或矩阵，则其中是向量或矩阵的值会调用tostring转为字符串后连接

```lua
v1 = vec4(1.0);
print('v1: ' .. v1); --> v1: [1.0, 1.0, 1.0, 1.0]
```

## Swizzling

Swizzling是一种可以快速方便地使用和修改向量内值的语法

对于一个向量`v`，我们提供了一组字母“`xyzw`”，字母‘`x`’、‘`y`’、‘`z`’、‘`w`’分别代表向量中的第一、第二、第三、第四个值，你可以在`v`后边任意混合、重复的使用这些字母以访问这些位置上的值，但你不能访问超出向量长度的位置上的值

```lua
v1 = vec4(1.0, 2.0, 3.0, 4.0);
v2 = v1.xyy;
print(v2); --> [1.0, 2.0, 2.0];

v2.zx = vec2(11.0, 12.0);
print(v2); --> [12.0, 2.0, 11.0];
--print(v2.wx); --'w'是访问第四个值，但v2只有3个值
```

特别的，如果只取一个值，那么返回的是`number`

```lua
v1 = vec3(1.0, 2.0, 3.0);
print(v1.z); --> 3.0
```

除此之外，“rgba”、“stpq”也可以像“xyzw”这样使用，与glsl不同，你可以混合使用不同组内的字母，当然我们并不推荐这样做

```lua
v1 = vec4(1.0, 2.0, 3.0, 4.0);
print(v1.xrs); --> [1.0, 1.0, 1.0]
```

习惯上，我们在将向量视为坐标向量时使用“`xyzw`”，视为颜色时使用“`rgba`”，视为纹理坐标时使用“`stpq`”

### 详细说明

以下会介绍一些非常规的用法，仅为帮助解释原理，为了代码的可读性不建议使用

Swizzling是通过重载索引和索引赋值运算实现的，在Lua中，形如a.abc的语句是a['abc']的语法糖，因此你可以在运行时生成一个合法的字符串变量`s`，然后使用形如v[s]的语句产生等同于Swizzling的效果，但我们完全可以用数组代替字符串，然后直接用数组中的数字进行索引，因此出于代码的可读性考虑，我们不建议这么使用

```lua
s = 'xyz'
v1 = vec4(1.0, 2.0, 3.0, 4.0);
print(v1[s]); --> [1.0, 2.0, 3.0]
```

在使用Swizzling取值的时候，Swizzling语句实际上根据字母序列生成了一个新向量并返回，因此你可以将该语句视为向量传进某个函数内或链式调用其他函数，甚至可以链式调用Swizzling，这种用法在某些需要连续多次链式改变排列顺序的情况下可能会有用，但大多数情况只会降低代码的可读性

```lua
v1 = vec3(1.0, 2.0, 3.0);
v2 = v1.yzx.yzx;
print(v2); --> [3.0, 1.0, 2.0]
```

在使用Swizzling赋值的时候，与glsl不同，对于一个位置的重复赋值是允许的，该位置被赋的值是其最后接收到的值，当然我们依然不建议对一个位置重复赋值

```lua
v1 = vec4(0.0);
v1.xyx = vec3(1.0, 2.0, 3.0);
print(v1); --> [3.0, 2.0, 0.0, 0.0]
```

与取值时不同，Swizzling在赋值时并不存在链式调用，在最后一次调用之前的调用都会被视为取值操作，而取值操作返回的是一个新的向量，最后的赋值操作又是基于这个新向量的，因此链式调用的Swizzling赋值操作将无法改变您原本希望被赋值的向量，您在任何情况下都不应该在赋值时链式调用Swizzling

```lua
v1 = vec3(1.0);
v1.xyz.xyz = vec3(2.0);
print(v1); --> [1.0, 1.0, 1.0]
```

## 与glsl的区别

出于效率和代码风格等因素，我们的实现中有许多细节与原生glsl语法不同，在编写时应该注意
1. 向量与矩阵第一个位置的索引数为1，而不是0
2. 我们实现的向量和矩阵只有`number`型，整形和浮点型可以同时出现在一个向量或矩阵内，我们没有实现布尔型的向量或矩阵
3. 在使用[Swizzling](##Swizzling)时，我们不会严格地禁止混合使用不同类型的字母，也不会阻止在被赋值向量中使用重复字母，详细说明请查阅[Swizzling](##Swizzling)小节

## 代码样例

导入相关库后将以下代码添加到工作区运行查看结果

```lua
v1 = vec2(1);
v2 = vec3(1, 2, 3);
v3 = vec4(1, vec2(2, 3), 4);
v4 = vec4(10, 20, 30, 40);
v5 = vec3(2);
v6 = vec4(1, 2, 3, 4);

print('v1:\n' .. v1 .. '\n');
print('v2:\n' .. v2 .. '\n');
print('v3:\n' .. v3 .. '\n');
print('v4:\n' .. v4 .. '\n');

print('getmetatable v1:\n' .. getmetatable(v1) .. '\n');

print('normalized v1:\n' .. v1:normalize() .. '\n');

print('length of v4:\n' .. #v4 .. '\n');
print('v4 - 1:\n' .. v4 - 1 .. '\n');
print('1 - v4:\n' .. v4 - 1 .. '\n');
print('v3 - v4:\n' .. v3 - v4 .. '\n');
print('v3 * 2:\n' .. v3 * 2 .. '\n');
print('2 * v3:\n' .. 2 * v3 .. '\n');

print('v3 dot v4:\n' .. v3:dot(v4) .. '\n');
print('v2 cross v5:\n' .. v2:cross(v5) ..  '\n');

print('v3 equle to v4:');
print(v3 == v4);
print('v3 equle to v6:');
print(v3 == v6);

print('v3[2]:\n' .. v3[2] .. '\n');

print('let v3[3] = 0, then v3:');
v3[3] = 0;
print(v3 .. '\n');
print('v3.wzyx:\n' .. v3.wzyx .. '\n');
print('let v4.xyz = v3.zyx, then v4:');
v4.xyz = v3.zyx;
print(v4 .. '\n');
		
m1 = mat2(1);
m2 = mat3(1,5,2,8,7,9,3,6,0);
m3 = mat4(1,vec3(2,3,4),vec2(5,6),vec2(7,8),9,10,11,12,vec4(13,14,15,16));
m4 = mat4x3(1, 4, 3, 6, 5, 4, 9, 7, 8, 2, 6, 4);
m5 = mat3x4(5, 6, 3, 5, 4, 7, 8, 9, 2, 0, 8, 5);
m6 = mat3x4(10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10);
m7 = mat2x3(m3);
m8 = mat4(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16);
m9 = mat4(4);

print('m1:\n' .. m1 .. '\n');
print('m2:\n' .. m2 .. '\n');
print('m3:\n' .. m3 .. '\n');
print('m4:\n' .. m4 .. '\n');
print('m5:\n' .. m5 .. '\n');
print('m6:\n' .. m6 .. '\n');
print('m7:\n' .. m7 .. '\n');
print('m8:\n' .. m8 .. '\n');
print('m9:\n' .. m9 .. '\n');

print('getmetatable m1:\n' .. getmetatable(m1) .. '\n');

print('m3 equle to m8:');
print(m3 == m8);
print();
print('m3 equle to m9:')
print(m3 == m9);
print();

print('transposed m2:\n' .. m2:transpose() .. '\n');
print('det of m2:\n' .. m2:det() .. '\n');
print('inv of m2:\n' .. m2:inv() .. '\n');
print('trace of m2:\n' .. m2:tr() .. '\n');
print('m2 squart:\n' .. m2 ^ 2 .. '\n');
print('m2 inv squart:\n' .. m2 ^ -2 .. '\n');
print('m2 ** 0:\n' .. m2 ^ 0 .. '\n');
print('length of a matrix nxm is n*m:\n' .. #m5 .. '\n');
print('m5 * m4:\n' .. m5 * m4 .. '\n');
print('m6 - m5:\n' .. m6 - m5 .. '\n');

print('m6 * 2\n' .. m6 * 2 .. '\n');
print('2 * m6\n' .. 2 * m6 .. '\n');
print('v3 * m6:\n' .. v3 * m6 .. '\n');
print('m6 * v2:\n' .. m6 * v2 .. '\n');

print('m7[2]:\n' .. m7[2] .. '\n');
print('m7[1][2]:\n' .. m7[1][2] .. '\n');

print('let m7[2] = vec3(4, 5, 6), then m7:');
m7[2] = vec3(4, 5, 6);
print(m7 .. '\n');

print('let m7[1][2] = 0, then m7:');
m7[1][2] = 0;
print(m7 .. '\n');

print('let m7[1].rb = m7[2].ts, then m7:');
m7[1].rb = m7[2].ts;
print(m7);
```
